# Mailchimp Mandrill Integration

Integrating [Mailchimp Mandrill](https://mailchimp.com/en/features/transactional-email/) is a powerfull way of [triggering scripts](../getting_started/8_trigger_scripts/index.md) or [flows](../getting_started/9_trigger_flows/index.md) by e-mail.

<video
    className="border-2 rounded-xl object-cover w-full h-full"
    autoPlay
    loop
    controls
    id="main-video"
    src="/videos/trigger_mandrill.mp4"
/>

<br/>

:::info TLDR

The present tutorial explains how to use Mailchimp to trigger Windmill [scripts](../getting_started/0_scripts_quickstart/1_typescript_quickstart/index.md) and [flows](../getting_started/6_flows_quickstart/index.md) through sending parsed inbound emails to Windmill via [webhooks](../core_concepts/4_webhooks/index.md).

:::

## Webhooks in Windmill

[Webhooks](../core_concepts/4_webhooks/index.md) in Windmill are a versatile and efficient method for triggering scripts or flows based on external events. Every script or flow created within the platform is automatically assigned a set of autogenerated webhooks, which can be found on the "Detail" page.

Combined with a token created in Windmill, these webhooks can be interacted with using standard web technologies, making them compatible with a broad range of external systems and services, including Mailchimp Mandrill for email-triggered executions.

![Webhook endpoints](../core_concepts/4_webhooks/webhook_endpoints.png)

> Each script or flow has webhook endpoints. Bearer token must be passed as either an Authorization: Bearer &lt;TOKEN&gt; header, or as a token query parameter: https://&lt;instance&gt;/&lt;route&gt;?token=&lt;TOKEN&gt;

## Using Mailchimp to trigger Windmill webhooks from emails

All the details are explained in [this tutorial](https://mailchimp.com/developer/transactional/guides/set-up-inbound-email-processing/) written by Mailchimp.

:::tip

The flow we used for the example is available on [Windmill Hub](https://hub.windmill.dev/flows/41/).

:::

Here are the steps to follow:

1. Create a [script](../getting_started/0_scripts_quickstart/1_typescript_quickstart/index.md) or [flow](../getting_started/6_flows_quickstart/index.md) in Windmill. Make sure it has an input designed to receive the parsed results (for example a string called "mandrill_events").

2. [Sign up to Mailchimp](https://mailchimp.com/signup/) (we used the free trial at first).

3. Go the the [inbound menu of Mailchimp Mandrill](https://mandrillapp.com/inbound).

4. Add a domain or sub-domain. For example `webhooks.domain.com`.

5. Add the MX records to your DNS provider and validate them from Mandrill.

6. From Mandrill, click the dropdown next to the `Test DNS Settings` button, select `Routes`, and then select the `Add New Route button`. Configure a new route. That will be the accepted email(s) to trigger your script or flow. Please note that these e-mail adresses do not have to pre-exist to be treated by Mailchimp.

7. From Windmill, go to the `Details` menu of your script or flow. If not any, create a token. Pick a webhook (`UUID/Async` [is commonly preferred](../core_concepts/4_webhooks/index.md#synchronous)).

8. In Mandrill's "Post to URL" box, paste the webhook in the form `https://app.windmill.dev/.../rest_of_the_webhook/?token=TOKEN`.

9. Click the `Test DNS Settings` button to check it's working.

Now you're all set!

Maybe you want to deal with the specific elements of the email. It is likely the payload has been sent as a string, so add a parsing to json step and use its results as inputs for further steps.

<details>
  <summary>Parses payload to Json. Code below:</summary>

  ```js
export async function main(x) {
return JSON.parse(x)
}
```

With "x" = our only input "flow_input.mandrill_events".
</details>

<details>
  <summary>Example of a simple parser to get info from the forwarded email. Code below:</summary>

  ```python
import re

def main(input_email):
    from_pattern = re.compile(r'From: .+ <(.+)>')
    subject_pattern = re.compile(r'Subject: (.+)')
    date_pattern = re.compile(r'Date: (.+)')
    to_pattern = re.compile(r'To: <(.+)>')
    content_pattern = re.compile(r'\n\n(.*)\n', re.DOTALL)

    from_field = re.search(from_pattern, input_email)
    date_field = re.search(date_pattern, input_email)
    subject_field = re.search(subject_pattern, input_email)
    to_field = re.search(to_pattern, input_email)
    content_field = re.search(content_pattern, input_email)

    return {
        'from': from_field.group(1) if from_field else None,
        'date': date_field.group(1) if date_field else None,
        'subject': subject_field.group(1) if subject_field else None,
        'to': to_field.group(1) if to_field else None,
        'content': content_field.group(1).strip() if content_field else None
    }

```

With "input_email" = "results.c[0].msg.text". c being the JSON parser step.
</details>

## How to go further?

The present example is a very simple use case: when an email is transfered to a given address, it triggers a flow that reports the main details of the mail to Slack.

However, you could go with much more complex workflows:
- The email could be dealt with to automatically update a CRM (e.g. [Hubspot](https://hub.windmill.dev/integrations/hubspot), [Salesforce](https://hub.windmill.dev/integrations/salesforce), [Airtable](https://hub.windmill.dev/integrations/airtable)).
- Use the parsed details to [branch the execution of your flow](../flows/13_flow_branches.md) on a condition.
- Have [OpenAI](https://hub.windmill.dev/integrations/openai) summarize the content of the email.
- Invoicing and Accounting: If your business receives invoices or receipts via email, you can parse these emails to extract relevant information and automatically update your accounting software or database.
- Monitoring and Alerting: If you're receiving system or application alerts via email, you can parse these emails and trigger specific workflows based on the type of alert. For example, you could automatically create a task in a project management tool, send a message in a Slack channel, or even trigger a script to attempt to resolve the issue automatically.

On top of much more custom-made uses only you can think of.